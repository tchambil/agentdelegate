package dcc.com.agent.message.si;

import java.util.List;
import org.apache.log4j.Logger;
import org.krams.tutorial.oxm.AddListRequest;
import org.krams.tutorial.oxm.Inventory;
import org.krams.tutorial.oxm.Order;
import org.krams.tutorial.oxm.Record;
import org.krams.tutorial.oxm.Sales;
import org.springframework.integration.Message;

/**
 *  Consolidates all messages before sending them to the next 
 *  process. In our case, the next process is a web service call.
 *  <p>
 *  This aggregator has the following behavior:
 *  <pre>
 *  1. Correlates messages based on the correlation id.
 *  The correlation id is auto-generated by Spring. 
 *  
 *  2. Messages are released once all the total messages have reached
 *  the total sequence size. The sequence size is  auto-generated by Spring. 
 *  
 *  3. Once released, the messages are added to a Record instance which
 *  is added to an instance of AddListRequest. This AddListRequest is the final
 *  message we send to the web service. JAXB will marshall this object to XML
 *  before sending to an external web service.
 *  </pre>
 *  @author Krams at {@link http://krams915@blogspot.com}
 */
public class ProductAggregator {

	protected static Logger logger = Logger.getLogger("integration");
	
	@SuppressWarnings("unchecked")
	public AddListRequest  send(List<Message> reqlist) {
		logger.debug("Total messages to send: " + reqlist.size()); 
		
		AddListRequest request = new AddListRequest();
		
		for (Message mess: reqlist) {
			// Verify first if record is valid. A filter is run for each record
			// Invalid records have the property valid = false
			if ( Boolean.valueOf(mess.getHeaders().get("valid").toString()) ) {
				Record record = new Record();
				
				if ( mess.getHeaders().get("keyword").toString().equalsIgnoreCase(ApplicationConstants.TYPE_SALES)) {
					record.setSales((Sales) mess.getPayload());
					request.getRecord().add(record);
					logger.debug("Added sales");
				}
				
				if ( mess.getHeaders().get("keyword").toString().equalsIgnoreCase(ApplicationConstants.TYPE_INVENTORY)) {
					record.setInventory((Inventory) mess.getPayload());
					request.getRecord().add(record);
					logger.debug("Added inventory");
				}
				
				if ( mess.getHeaders().get("keyword").toString().equalsIgnoreCase(ApplicationConstants.TYPE_ORDER)) {
					record.setOrder((Order) mess.getPayload());
					request.getRecord().add(record);
					logger.debug("Added order");
				}
			}
		}
		
		return request;
	}
	
	public boolean release(List<Message<?>> messages) {
		logger.debug("Message size: " + messages.size());
		logger.debug("Sequence size: " + messages.get(0).getHeaders().getSequenceSize());
		
		if (messages.size() == messages.get(0).getHeaders().getSequenceSize()) {
			logger.debug("Now releasing ...");
			return true;
		}
	    logger.debug("Pending release ...");
	    return false;
	  }
	
	public String correlate(Message<?> message) {
		logger.debug("Correlate by: " + message.getHeaders().getCorrelationId().toString());
		logger.debug("Get keyword header: " + message.getHeaders().get("keyword").toString());
		return message.getHeaders().getCorrelationId().toString();
	}
}
